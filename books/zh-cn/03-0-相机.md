# 3.0 - 相机

　　在3D游戏中，可以通过鼠标和键盘操纵角色在场景中漫游，然而在图形中并没有真正的相机，一切的物体都是虚拟想象出来的，正是这种虚拟特性，给予了比实际更多的控制性。

​	我们需要构建一个相机系统，能够实现虚拟漫游，使其达到对于同一物体而言，观察者可以从不同的角度来观察物体，因此我们需要构造一个观察矩阵，并且为了在显示器上显示场景中的三维物体，需要把三维物体投影到二维的观察平面上，最终形成二维图像，这将会涉及到多个坐标系间的转化。本文从最简单的视口坐标系开始。

#### 视口

　　视口（Viewport），它是一个矩形的区域，长度单位是像素，视口的位置和大小在视口坐标系中定义。视口坐标系是直角坐标系，其原点位于渲染环境窗口客户区的左上角，横轴(x)向右为正，纵轴(y)向下为正，如下图所示。大多数程序中，使用一个视口就行了，视口一般是基于已经定义的窗体大小自动调整的。
$$
\begin{array}{ccc|lll}
\\
\hline
&{}&{}&{O}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{x→}\\
\\
\\
\\
\\
&{}&{}&{y}\\
&{}&{}&{↓}\\
\end{array}\tag{1}
$$


#### 视图变换

　　在渲染中，改变相机的位置和观察角度行为被成为**视图变换**（View），而改变模型的位置和角度则被称为**模型变换**（Model），这两个变换，都会影响最终图形，物体的位置，角度，而这两种变换都可以达到相同的效果，例如，你想要一个倒立的图像，可以把物体倒立过来，这样看到的物体就是倒立的，或者也可以将相机倒立过来。

　　当一个相机对准某一个物体点 ***P***（x, y），其最终生成的物体在图像任意一点 ***E***, 假设点 ***P*** 移动了$$M_{model}$$个单位，当相机 **C** 以相同的距离移动了$$M_{model}$$个单位，根据之前我们学到的在齐次坐标下的平移变换，点 ***P*** 和 点 ***P'*** 的关系，以及相机 ***C*** 和 相机 ***C'*** 的关系为：
$$
P' = P * M_{model}\\
C' = C * M_{model}\tag{3}
$$
　　相机 ***C'*** 和 ***P'***  由于移动的距离相同，则最终生成的影像，点 ***P'*** 在图像上的点 ***E'*** 应当和图像 ***E*** 重合，那么相机 ***C'*** 和 ***P'***  的关系为：
$$
E = P'-C' = P - C
$$

​	引入齐次坐标后则相机 ***C*** 和 ***P***  的关系为：
$$
E = P * M_{model} * (C * M_{model})-1
$$
　　在DirectX中，总是将相机 **C** 的位置定义在(0,0,0)点，因此我们可以简单的把**视图矩阵**写为:
$$
M_{view} = M_{model}-1
$$
​	通过模型矩阵(Model Matrix)和视图矩阵（View Matrix）的组合(Model View)，我们实现了对于同一物体而言，观察者（Eye space）可以从不同的角度来观察物体，我们得出了在观察者角度下的变换矩阵，其公式为：
$$
\left[\begin{matrix}
  x_{eye}\\
  y_{eye}\\
  z_{eye}\\
  w_{eye}\\
  \end{matrix} \right]=
  \left[\begin{matrix}
  x_{obj}\\
  y_{obj}\\
  z_{obj}\\
  w_{obj} 
   \end{matrix} \right]*
  M_{model} * M_{view}
$$


